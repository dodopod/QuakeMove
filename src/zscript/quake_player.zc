// Code adapted from PlayerPawn & DoomPlayer in gzdoom.pk3

class QuakePlayer : DoomPlayer
{
    // Aliases for Player.Forward/SideMove
    Property ForwardMove : forwardMove1, forwardMove2;
    Property SideMove : sideMove1, sideMove2;

    Property UpMove : upMove;


    Default
    {
		Speed 320.0 / ticRate;  // No idea how close Doom & Quake units are, but it feels right

        QuakePlayer.UpMove 1;
    }


    const straferunningCVar = "G_Straferunning";
    const strafejumpingCVar = "G_Strafejumping";

    const maxForwardMove = 12800;
    const maxSideMove = 10240;
    const maxUpMove = 768;
    const stopFlying = -32768;

    const normalFriction = 0.8125;
    const acceleration = 10.0 / ticRate / normalFriction;

    enum EWaterLevel
    {
        WL_NotInWater   = 0,
        WL_Feet         = 1,
        WL_Waist        = 2,
        WL_Eyes         = 3
    }

    enum EMoveType
    {
        MT_Walk,
        MT_Water,
        MT_Fly,
        MT_Air
    }


    double upMove;


    override void PlayerThink()
    {
        bool predicting = player.cheats & CF_Predicting;

        CheckFOV();
        if (player.inventoryTics) --player.inventoryTics;
        CheckCheats();

		if (player.playerState == PST_Dead)
		{   // Is there a reason CheckCrouch is before this in gzdoom.pk3?
			DeathThink();
			return;
		}
		if (player.morphTics && !predicting)
		{
			MorphPlayerThink();
		}

		player.onGround = (pos.z <= floorZ) || bOnMobj || bMBFBouncer || (player.cheats & CF_NoClip2);
        HandleMovement();

        if (!predicting)
        {
            // NOTE: CheckUndoMorph may change PlayerPawn, and invalidate self.player (I think)
            PlayerInfo player = self.player;

            CheckEnvironment();
			CheckUse();
			CheckUndoMorph();

			player.mo.TickPSprites();

			// Other Counters
			if (player.damagecount)	player.damagecount--;
			if (player.bonuscount) player.bonuscount--;

            // Strife-style poison
			if (player.hazardcount)
			{
				player.hazardcount--;
				if (!(level.time % player.hazardinterval) && player.hazardcount > 16 * ticRate)
					player.mo.DamageMobj (NULL, NULL, 5, player.hazardtype);
			}

			player.mo.CheckPoison();
			player.mo.CheckDegeneration();
			player.mo.CheckAirSupply();
        }
    }


    override void HandleMovement()
    {
        FixPlayerInput();
        CheckCrouch(CheckFrozen());

        CheckPitch();

		if (reactiontime)
		{   // Player is frozen
			reactiontime--;
		}
		else
		{
            CheckYaw();

            vel *= GetFriction();   // Quake applies friction before movement
            switch (GetMoveType())
            {
            case MT_Walk:
                WalkMove();
                break;
            case MT_Fly:
                FlyMove();
                break;
            case MT_Water:
                WaterMove();
                break;
            case MT_Air:
                AirMove();
                break;
            }
            vel /= GetFriction();
		}

        CalcHeight();   // Vertical bob
    }


    // Modifies player input in special circumstances
    virtual void FixPlayerInput()
    {
        UserCmd cmd = player.cmd;

        PullIn();

        switch (GetMoveType())
        {
        case MT_Fly:
        case MT_Water:
            if (IsPressed(BT_Jump))
            {
                //cmd.buttons &= ~BT_Jump;
                cmd.upMove = maxUpMove;
            }

            if (IsPressed(BT_Crouch))
            {
                //cmd.buttons &= ~BT_Crouch;
                cmd.upMove = -maxUpMove;
            }

            break;
        }
    }


    // Chainsaw/Gauntlets attack auto forward motion
    virtual void PullIn()
    {
        UserCmd cmd = player.cmd;

		if (bJustAttacked)
		{
			cmd.yaw = 0;
			cmd.forwardmove = 0xc800/2;
			cmd.sidemove = 0;
			bJustAttacked = false;
		}
    }


    // Handle player turning
    virtual void CheckYaw()
    {
        UserCmd cmd = player.cmd;

        // [RH] Check for fast turn around
		if (player.cmd.buttons & BT_TURN180 && !(player.oldbuttons & BT_TURN180))
		{
			player.turnticks = TURN180_TICKS;
		}

		// [RH] 180-degree turn overrides all other yaws
		if (player.turnticks)
		{
			player.turnticks--;
			Angle += (180. / TURN180_TICKS);
		}
		else
		{
			Angle += cmd.yaw * (360./65536.);
		}
    }


    override void CheckCrouch(bool totallyFrozen)
    {
        UserCmd cmd = player.cmd;
        Super.CheckCrouch(totallyFrozen);

        if (CanCrouch())
        {   // Crouch reduces speed
            cmd.forwardMove *= player.crouchFactor;
            cmd.sideMove *= player.crouchFactor;
        }
    }


    override void CheckJump()
    {
        // Copypasted from PlayerThink
		if (player.jumpTics != 0)
		{
			player.jumpTics--;
			if (player.onground && player.jumpTics < -18)
			{
				player.jumpTics = 0;
			}
		}

        if (player.onGround) player.jumpTics = 0;       // Enable bunnyhopping
        if (JustPressed(BT_Jump))                       // But don't make it automatic
        {
            vel /= GetFriction();   // No friction on same tic as jump (makes strafejumping easier)
            Super.CheckJump();
        }
    }


    virtual void WalkMove()
    {
		UserCmd cmd = player.cmd;

        // Start flying
        if (cmd.upMove)
        {
            if (bFly || (player.cheats & CF_NOCLIP2))
            {
                bFly = true;
                bNoGravity = true;

                if ((Vel.Z <= -39) && !(player.cheats & CF_PREDICTING))
                {   // Stop falling scream
                    A_StopSound(CHAN_VOICE);
                }

                FlyMove();
                return;
            }
            else if (cmd.upMove > 0 && !(player.cheats & CF_PREDICTING))
			{
				let fly = FindInventory("ArtiFly");
				if (fly)
                {
                    UseInventory(fly);

                    FlyMove();
                    return;
                }
			}
        }

        CheckJump();

        if (cmd.forwardMove || cmd.sideMove)
        {
			double fm = cmd.forwardmove;
			double sm = cmd.sidemove;
			[fm, sm] = TweakSpeeds(fm, sm);
            fm /= maxForwardMove;
            sm /= maxSideMove;

            Vector3 forward = (AngleToVector(angle), 0);
            Vector3 right = (AngleToVector(angle - 90), 0);
            Vector3 wishVel = fm * forward + sm * right;

            Vector3 wishDir = wishVel.Unit();
            double wishSpeed = wishVel.Length() * speed;
            bool canStraferun = CVar.FindCVar(straferunningCVar).GetBool();
            if (!canStraferun) wishSpeed = Clamp(wishVel.Length() * speed, 0, speed);

            Accelerate(wishDir, wishSpeed, GetMoveFactor() * acceleration);
            BobAccelerate(wishDir, wishSpeed, GetMoveFactor() * acceleration);

            // Running animation
			if (!(player.cheats & CF_PREDICTING) && (fm != 0 || sm != 0)) PlayRunning();

            // Return to 1st person (from security camera?)
			if (player.cheats & CF_RevertPlease)
			{
				player.cheats &= ~CF_RevertPlease;
				player.camera = player.mo;
			}
        }
    }


    virtual void FlyMove()
    {
		UserCmd cmd = player.cmd;

        if (cmd.upMove == stopFlying)
        {
            bNoGravity = false;
            cmd.upMove = 0; // To avoid AirMove calling FlyMove again
            AirMove();
            return;
        }

        if (cmd.forwardMove || cmd.sideMove || cmd.upMove)
        {
			double fm = cmd.forwardmove;
			double sm = cmd.sidemove;
            double um = cmd.upMove;
            [fm, sm, um] = TweakSpeeds3(fm, sm, um);
            fm /= maxForwardMove;
            sm /= maxSideMove;
            um /= maxUpMove;

            Vector3 forward = (Cos(pitch) * Cos(angle), Cos(pitch) * Sin(angle), -Sin(pitch));
            Vector3 right = (AngleToVector(angle - 90), 0);
            Vector3 wishVel = fm * forward + sm * right;
            wishVel.z += um;

            Vector3 wishDir = wishVel.Unit();
            double wishSpeed = wishVel.Length() * speed;
            bool canStraferun = CVar.FindCVar(straferunningCVar).GetBool();
            if (!canStraferun) wishSpeed = Clamp(wishVel.Length() * speed, 0, speed);

            Accelerate(wishDir, wishSpeed, GetMoveFactor() * acceleration);
            BobAccelerate(wishDir, wishSpeed, GetMoveFactor() * acceleration);

            // Running animation
			if (!(player.cheats & CF_PREDICTING) && (fm != 0 || sm != 0)) PlayRunning();

            // Return to 1st person (from security camera?)
			if (player.cheats & CF_RevertPlease)
			{
				player.cheats &= ~CF_RevertPlease;
				player.camera = player.mo;
			}
        }
    }


    virtual void WaterMove()
    {
		UserCmd cmd = player.cmd;

        if (cmd.forwardMove || cmd.sideMove || cmd.upMove)
        {
			double fm = cmd.forwardmove;
			double sm = cmd.sidemove;
            double um = cmd.upMove;
            [fm, sm, um] = TweakSpeeds3(fm, sm, um);
            fm /= maxForwardMove;
            sm /= maxSideMove;
            um /= maxUpMove;

            Vector3 forward = (Cos(pitch) * Cos(angle), Cos(pitch) * Sin(angle), -Sin(pitch));
            Vector3 right = (AngleToVector(angle - 90), 0);
            Vector3 wishVel = fm * forward + sm * right;
            wishVel.z += um;

            if (waterLevel == WL_Feet && wishVel.z > 0) wishVel.z = 0;   // Swim on surface
            if (wishVel.Length() == 0) return;

            Vector3 wishDir = wishVel.Unit();
            double wishSpeed = wishVel.Length() * speed;
            bool canStraferun = CVar.FindCVar(straferunningCVar).GetBool();
            if (!canStraferun) wishSpeed = Clamp(wishVel.Length() * speed, 0, speed);

            Accelerate(wishDir, wishSpeed, GetMoveFactor() * acceleration);
            BobAccelerate(wishDir, wishSpeed, GetMoveFactor() * acceleration);

            // Running animation
			if (!(player.cheats & CF_PREDICTING) && (fm != 0 || sm != 0)) PlayRunning();

            // Return to 1st person (from security camera?)
			if (player.cheats & CF_RevertPlease)
			{
				player.cheats &= ~CF_RevertPlease;
				player.camera = player.mo;
			}
        }
    }


    virtual void AirMove()
    {
		UserCmd cmd = player.cmd;

        // Start flying
        if (cmd.upMove)
        {
            if (bFly || (player.cheats & CF_NOCLIP2))
            {
                bFly = true;
                bNoGravity = true;

                if ((Vel.Z <= -39) && !(player.cheats & CF_PREDICTING))
                {   // Stop falling scream
                    A_StopSound(CHAN_VOICE);
                }

                FlyMove();
                return;
            }
            else if (cmd.upMove > 0 && !(player.cheats & CF_PREDICTING))
			{
				let fly = FindInventory("ArtiFly");
				if (fly)
                {
                    UseInventory(fly);

                    FlyMove();
                    return;
                }
			}
        }

        if (cmd.forwardMove || cmd.sideMove)
        {
			double fm = cmd.forwardmove;
			double sm = cmd.sidemove;
			[fm, sm] = TweakSpeeds(fm, sm);
            fm /= maxForwardMove;
            sm /= maxSideMove;

            Vector3 forward = (AngleToVector(angle), 0);
            Vector3 right = (AngleToVector(angle - 90), 0);
            Vector3 wishVel = fm * forward + sm * right;

            Vector3 wishDir = wishVel.Unit();
            double wishSpeed = wishVel.Length() * speed;
            bool canStraferun = CVar.FindCVar(straferunningCVar).GetBool();
            if (!canStraferun) wishSpeed = Clamp(wishVel.Length() * speed, 0, speed);

            double accel = GetMoveFactor() * acceleration * level.airControl;
            Accelerate(wishDir, wishSpeed, accel);
            BobAccelerate(wishDir, wishSpeed, accel);

            // Running animation
			if (!(player.cheats & CF_PREDICTING) && (fm != 0 || sm != 0)) PlayRunning();

            // Return to 1st person (from security camera?)
			if (player.cheats & CF_RevertPlease)
			{
				player.cheats &= ~CF_RevertPlease;
				player.camera = player.mo;
			}
        }
    }


    virtual double, double, double TweakSpeeds3(double forward, double side, double up)
    {
        [forward, side] = TweakSpeeds(forward, side);

        up *= upMove;

        return forward, side, up;
    }


    virtual void Accelerate(Vector3 wishDir, double wishSpeed, double accel)
    {
        if (CVar.FindCVar(strafejumpingCVar).GetBool())
        {
            double currentSpeed = vel dot wishDir;

            double addSpeed = wishSpeed - currentSpeed;
            if (addSpeed <= 0) return;

            double accelSpeed = Min(accel * wishSpeed, addSpeed);

            vel += accelSpeed * wishDir;
        }
        else
        {   // Disabled code in Quake 3
            Vector3 pushDir = wishSpeed * wishDir - vel;
            double pushLen = pushDir.Length();
            if (pushLen == 0) return;
            pushDir = pushDir.Unit();

            double canPush = Min(accel * wishSpeed, PushLen);

            vel += canPush * pushDir;
        }
    }


    virtual void BobAccelerate(Vector3 wishDir, double wishSpeed, double accel)
    {
        double currentSpeed = player.vel dot wishDir.xy;

        double addSpeed = wishSpeed - currentSpeed;
        if (addSpeed <= 0) return;

        double accelSpeed = Clamp(accel * wishSpeed, 0, addSpeed);

        player.vel += accelSpeed * wishDir.xy;
    }


    // Returns whether player is walking, swimming, etc.
    virtual int GetMoveType()
    {   // NOTE: Order is important
        if (bNoGravity)         return MT_Fly;      // So we can take off when on ground
        if (player.onGround)    return MT_Walk;     // So we can walk in shallow water
        if (waterLevel)         return MT_Water;
        else                    return MT_Air;
    }


    // Slow player down if ground is slippery/sticky
    virtual double GetMoveFactor()
    {
        double friction = GetFriction();

        if (friction > normalFriction) return 1 - ((friction - normalFriction) / (1 - normalFriction));
        else if (friction < normalFriction) return 1 - ((normalFriction - friction) / normalFriction);
        else return 1;
    }


    bool IsPressed(int bt)
    {
        return player.cmd.buttons & bt;
    }


    bool JustPressed(int bt)
    {
        return (player.cmd.buttons & bt) && !(player.oldButtons & bt);
    }
}
