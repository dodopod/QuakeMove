// Code adapted from PlayerPawn & DoomPlayer in gzdoom.pk3

class QuakePlayer : DoomPlayer
{
    // Aliases for Player.Forward/SideMove
    Property ForwardMove : forwardMove1, forwardMove2;
    Property SideMove : sideMove1, sideMove2;

    Property UpMove : upMove;


    Default
    {
		Speed 320.0 / ticRate;  // No idea how close Doom & Quake units are, but it feels right

        QuakePlayer.UpMove 1;
    }


    const maxForwardMove = 12800;
    const maxSideMove = 10240;
    const maxUpMove = 768;
    const stopFlying = -32768;

    const normalFriction = 0.77;
    const acceleration = 10.0 / ticRate;

    enum EWaterLevel
    {
        WL_NotInWater   = 0,
        WL_Feet         = 1,
        WL_Waist        = 2,
        WL_Eyes         = 3
    }

    enum EMoveType
    {
        MT_Walk,
        MT_Water,
        MT_Fly,
        MT_Air
    }


    double upMove;


    override void PlayerThink()
    {
        bool predicting = player.cheats & CF_Predicting;

        CheckFOV();
        if (player.inventoryTics) --player.inventoryTics;
        CheckCheats();

		if (player.playerState == PST_Dead)
		{   // Is there a reason CheckCrouch is before this in gzdoom.pk3?
			DeathThink();
			return;
		}
		if (player.morphTics && !predicting)
		{
			MorphPlayerThink();
		}

		player.onGround = (pos.z <= floorZ) || bOnMobj || bMBFBouncer || (player.cheats & CF_NoClip2);
        HandleMovement();

        if (!predicting)
        {
            // NOTE: CheckUndoMorph may change PlayerPawn, and invalidate self.player (I think)
            PlayerInfo player = self.player;

            CheckEnvironment();
			CheckUse();
			CheckUndoMorph();

			player.mo.TickPSprites();

			// Other Counters
			if (player.damagecount)	player.damagecount--;
			if (player.bonuscount) player.bonuscount--;

            // Strife-style poison
			if (player.hazardcount)
			{
				player.hazardcount--;
				if (!(level.time % player.hazardinterval) && player.hazardcount > 16 * ticRate)
					player.mo.DamageMobj (NULL, NULL, 5, player.hazardtype);
			}

			player.mo.CheckPoison();
			player.mo.CheckDegeneration();
			player.mo.CheckAirSupply();
        }
    }


    override void HandleMovement()
    {
        FixPlayerInput();
        CheckCrouch(CheckFrozen());

        CheckPitch();

		// Handle movement
		if (reactiontime)
		{ // Player is frozen
			reactiontime--;
		}
		else
		{
            CheckYaw();

            /*
			MovePlayer();
			CheckJump();
			CheckMoveUpDown();*/

            switch (GetMoveType())
            {
            case MT_Walk:
                //Console.Printf("walking");
                WalkMove();
                break;
            case MT_Fly:
                //Console.Printf("flying");
                FlyMove();
                break;
            case MT_Water:
                //Console.Printf("swimming");
                WaterMove();
                break;
            case MT_Air:
                //Console.Printf("falling");
                AirMove();
                break;
            }
		}

        CalcHeight();   // Vertical bob
    }


    // Modifies player input in special circumstances
    virtual void FixPlayerInput()
    {
        UserCmd cmd = player.cmd;

        PullIn();

        switch (GetMoveType())
        {
        case MT_Fly:
        case MT_Water:
            if (IsPressed(BT_Jump))
            {
                cmd.buttons &= ~BT_Jump;
                cmd.upMove = maxUpMove;
            }

            if (IsPressed(BT_Crouch))
            {
                cmd.buttons &= ~BT_Crouch;
                cmd.upMove = -maxUpMove;
            }

            break;
        }
    }


    // Chainsaw/Gauntlets attack auto forward motion
    virtual void PullIn()
    {
        UserCmd cmd = player.cmd;

		if (bJustAttacked)
		{
			cmd.yaw = 0;
			cmd.forwardmove = 0xc800/2;
			cmd.sidemove = 0;
			bJustAttacked = false;
		}
    }


    // Handle player turning
    virtual void CheckYaw()
    {
        UserCmd cmd = player.cmd;

        // [RH] Check for fast turn around
		if (player.cmd.buttons & BT_TURN180 && !(player.oldbuttons & BT_TURN180))
		{
			player.turnticks = TURN180_TICKS;
		}

		// [RH] 180-degree turn overrides all other yaws
		if (player.turnticks)
		{
			player.turnticks--;
			Angle += (180. / TURN180_TICKS);
		}
		else
		{
			Angle += cmd.yaw * (360./65536.);
		}
    }


    override void CheckCrouch(bool totallyFrozen)
    {
        UserCmd cmd = player.cmd;
        Super.CheckCrouch(totallyFrozen);

        if (CanCrouch())
        {   // Crouch reduces speed
            cmd.forwardMove *= player.crouchFactor;
            cmd.sideMove *= player.crouchFactor;
        }
    }


    override void CheckJump()
    {
        // Copypasted from PlayerThink
		if (player.jumpTics != 0)
		{
			player.jumpTics--;
			if (player.onground && player.jumpTics < -18)
			{
				player.jumpTics = 0;
			}
		}

        if (player.onGround) player.jumpTics = 0;       // Enable bunnyhopping
        if (JustPressed(BT_Jump)) Super.CheckJump();    // But don't make it automatic
    }


    virtual void WalkMove()
    {
		UserCmd cmd = player.cmd;

        if (cmd.upMove)
        {
            if (bFly || (player.cheats & CF_NOCLIP2))
            {
                bFly = true;
                bNoGravity = true;

                if ((Vel.Z <= -39) && !(player.cheats & CF_PREDICTING))
                {   // Stop falling scream
                    A_StopSound(CHAN_VOICE);
                }

                FlyMove();
                return;
            }
            else if (cmd.upMove > 0 && !(player.cheats & CF_PREDICTING))
			{
				let fly = FindInventory("ArtiFly");
				if (fly)
                {
                    UseInventory(fly);

                    FlyMove();
                    return;
                }
			}
        }

        if (cmd.forwardMove || cmd.sideMove)
        {
			double fm = cmd.forwardmove;
			double sm = cmd.sidemove;
			[fm, sm] = TweakSpeeds(fm, sm);
            fm /= maxForwardMove;
            sm /= maxSideMove;

            Vector3 forward = (AngleToVector(angle), 0);
            Vector3 right = (AngleToVector(angle - 90), 0);
            Vector3 wishVel = fm * forward + sm * right;

            Vector3 wishDir = wishVel.Unit();
            double wishSpeed = Clamp(wishVel.Length() * speed, 0, speed);   // TODO: straferun CVar

            Accelerate(wishDir, wishSpeed, GetMoveFactor() * acceleration);
            BobAccelerate(wishDir, wishSpeed, GetMoveFactor() * acceleration);

            // Running animation
			if (!(player.cheats & CF_PREDICTING) && (fm != 0 || sm != 0)) PlayRunning();

            // Return to 1st person (from security camera?)
			if (player.cheats & CF_RevertPlease)
			{
				player.cheats &= ~CF_RevertPlease;
				player.camera = player.mo;
			}
        }

        CheckJump();
    }


    virtual void FlyMove()
    {
		UserCmd cmd = player.cmd;

        if (cmd.upMove == stopFlying)
        {
            bNoGravity = false;
            AirMove();
            return;
        }

        if (cmd.forwardMove || cmd.sideMove || cmd.upMove)
        {
			double fm = cmd.forwardmove;
			double sm = cmd.sidemove;
            double um = cmd.upMove;
            [fm, sm, um] = TweakSpeeds3(fm, sm, um);
            fm /= maxForwardMove;
            sm /= maxSideMove;
            um /= maxUpMove;

            Vector3 forward = (Cos(pitch) * Cos(angle), Cos(pitch) * Sin(angle), -Sin(pitch));
            Vector3 right = (AngleToVector(angle - 90), 0);
            Vector3 wishVel = fm * forward + sm * right;
            wishVel.z += um;

            Vector3 wishDir = wishVel.Unit();
            double wishSpeed = Clamp(wishVel.Length() * speed, 0, speed);   // TODO: straferun CVar

            Accelerate(wishDir, wishSpeed, GetMoveFactor() * acceleration);
            BobAccelerate(wishDir, wishSpeed, GetMoveFactor() * acceleration);

            // Running animation
			if (!(player.cheats & CF_PREDICTING) && (fm != 0 || sm != 0)) PlayRunning();

            // Return to 1st person (from security camera?)
			if (player.cheats & CF_RevertPlease)
			{
				player.cheats &= ~CF_RevertPlease;
				player.camera = player.mo;
			}
        }
    }


    virtual void WaterMove()
    {
		UserCmd cmd = player.cmd;

        if (cmd.forwardMove || cmd.sideMove || cmd.upMove)
        {
			double fm = cmd.forwardmove;
			double sm = cmd.sidemove;
            double um = cmd.upMove;
            [fm, sm, um] = TweakSpeeds3(fm, sm, um);
            fm /= maxForwardMove;
            sm /= maxSideMove;
            um /= maxUpMove;

            Vector3 forward = (Cos(pitch) * Cos(angle), Cos(pitch) * Sin(angle), -Sin(pitch));
            Vector3 right = (AngleToVector(angle - 90), 0);
            Vector3 wishVel = fm * forward + sm * right;
            wishVel.z += um;

            Vector3 wishDir = wishVel.Unit();
            double wishSpeed = Clamp(wishVel.Length() * speed, 0, speed);   // TODO: straferun CVar

            Accelerate(wishDir, wishSpeed, GetMoveFactor() * acceleration);
            BobAccelerate(wishDir, wishSpeed, GetMoveFactor() * acceleration);

            // Running animation
			if (!(player.cheats & CF_PREDICTING) && (fm != 0 || sm != 0)) PlayRunning();

            // Return to 1st person (from security camera?)
			if (player.cheats & CF_RevertPlease)
			{
				player.cheats &= ~CF_RevertPlease;
				player.camera = player.mo;
			}
        }
    }


    virtual void AirMove()
    {
		UserCmd cmd = player.cmd;

        if (cmd.upMove)
        {
            if (bFly || (player.cheats & CF_NOCLIP2))
            {
                bFly = true;
                bNoGravity = true;

                if ((Vel.Z <= -39) && !(player.cheats & CF_PREDICTING))
                {   // Stop falling scream
                    A_StopSound(CHAN_VOICE);
                }

                FlyMove();
                return;
            }
            else if (cmd.upMove > 0 && !(player.cheats & CF_PREDICTING))
			{
				let fly = FindInventory("ArtiFly");
				if (fly)
                {
                    UseInventory(fly);

                    FlyMove();
                    return;
                }
			}
        }

        if (cmd.forwardMove || cmd.sideMove)
        {
			double fm = cmd.forwardmove;
			double sm = cmd.sidemove;
			[fm, sm] = TweakSpeeds(fm, sm);
            fm /= maxForwardMove;
            sm /= maxSideMove;

            Vector3 forward = (AngleToVector(angle), 0);
            Vector3 right = (AngleToVector(angle - 90), 0);
            Vector3 wishVel = fm * forward + sm * right;

            //Console.Printf("wishVel = (%.2f, %.2f, %.2f)", wishVel.x, wishVel.y, wishVel.z);

            Vector3 wishDir = wishVel.Unit();
            double wishSpeed = Clamp(wishVel.Length() * speed, 0, speed);   // TODO: straferun CVar

            double accel = GetMoveFactor() * acceleration;
            if (!waterLevel) accel *= level.airControl;     // So that swimming works

            Accelerate(wishDir, wishSpeed, accel);
            BobAccelerate(wishDir, wishSpeed, accel);

            // Running animation
			if (!(player.cheats & CF_PREDICTING) && (fm != 0 || sm != 0)) PlayRunning();

            // Return to 1st person (from security camera?)
			if (player.cheats & CF_RevertPlease)
			{
				player.cheats &= ~CF_RevertPlease;
				player.camera = player.mo;
			}
        }
    }


    // Allow player to move/turn
    // NOTE: Called from HandleMovement, called from PlayerThink
    // NOTE: Doesn't handle
    //  - Vertical look (CheckPitch, called from PlayerThink)
    //  - Crouching (CheckCrouch, called from PlayerThink)
    //  - Jumping (CheckJump, called from HandleMovement, called from PlayerThink)
    //  - Up/down flight/swimming (CheckMoveUpDown, called from HandleMovement, called from PlayerThink)
    /*override void MovePlayer()
    {
        let player = self.player;
		UserCmd cmd = player.cmd;

        // TODO: Air, water, walk move functions

		// killough 10/98:
		//
		// We must apply thrust to the player and bobbing separately, to avoid
		// anomalies. The thrust applied to bobbing is always the same strength on
		// ice, because the player still "works just as hard" to move, while the
		// thrust applied to the movement varies with 'movefactor'.

		if (cmd.forwardmove | cmd.sidemove)
		{
			double forwardmove, sidemove;
			double bobfactor;
			double friction, movefactor;
			double fm, sm;

			//[friction, movefactor] = GetFriction();
			//bobfactor = friction < ORIG_FRICTION ? movefactor : ORIG_FRICTION_FACTOR;
            moveFactor = GetMoveFactor();
            bobfactor = ORIG_FRICTION_FACTOR;
			if (!player.onground && !bNoGravity && !waterlevel)
			{
				// [RH] allow very limited movement if not on ground.
				movefactor *= level.aircontrol;
				bobfactor *= level.aircontrol;
			}

			fm = cmd.forwardmove;
			sm = cmd.sidemove;
			[fm, sm] = TweakSpeeds (fm, sm);
            fm /= maxForwardMove;
            sm /= maxSideMove;
			/*fm *= Speed / 256;
			sm *= Speed / 256;*//*

			// When crouching, speed and bobbing have to be reduced
			if (CanCrouch() && player.crouchfactor != 1)
			{
				fm *= player.crouchfactor;
				sm *= player.crouchfactor;
				bobfactor *= player.crouchfactor;
			}

			/*forwardmove = fm * movefactor * (35 / TICRATE);
			sidemove = sm * movefactor * (35 / TICRATE);

			if (forwardmove)
			{
				Bob(Angle, cmd.forwardmove * bobfactor / 256., true);
				ForwardThrust(forwardmove, Angle);
			}
			if (sidemove)
			{
				let a = Angle - 90;
				Bob(a, cmd.sidemove * bobfactor / 256., false);
				Thrust(sidemove, a);
			}*//*

            Vector3 forward;
            if ((waterlevel || bNoGravity) && Pitch != 0 && !player.GetClassicFlight())
            {   // Fly/swim up/down
                forward = (Cos(pitch) * Cos(angle), Cos(pitch) * Sin(angle), -Sin(pitch));
            }
            else
            {
                forward = (AngleToVector(angle), 0);
            }

            Vector3 right = (AngleToVector(angle - 90), 0);

            //Vector2 wishVel = AngleToVector(angle, fm) + AngleToVector(angle - 90, sm);
            Vector3 wishVel = fm * forward + sm * right;
            Vector3 wishDir = wishVel.Unit();  // TODO: move up, when flying/swimming
            double wishSpeed = Clamp(wishVel.Length() * speed, 0, speed);   // TODO: straferun CVar

            //Console.Printf("wishDir = (%.2f, %.2f)", wishDir.x, wishDir.y);
            //Console.Printf("wishSpeed = %.2f", wishSpeed);
            //Console.Printf("friction = %.2f", friction);
            //Console.Printf("vel = %.2f", vel.Length());

            Accelerate(wishDir, wishSpeed, moveFactor * acceleration);

            Bob(Angle, cmd.forwardmove * bobfactor / 256., true);
            Bob(Angle - 90, cmd.sidemove * bobfactor / 256., false);

			if (!(player.cheats & CF_PREDICTING) && (forwardmove != 0 || sidemove != 0))
			{
				PlayRunning ();
			}

			if (player.cheats & CF_REVERTPLEASE)
			{
				player.cheats &= ~CF_REVERTPLEASE;
				player.camera = player.mo;
			}
		}

        //if (vel.xy.Length() > speed) Console.Printf("%.2f UPS", vel.xy.Length() * ticRate);
    }*/


    virtual double, double, double TweakSpeeds3(double forward, double side, double up)
    {
        [forward, side] = TweakSpeeds(forward, side);

        up *= upMove;

        return forward, side, up;
    }


    virtual void Accelerate(Vector3 wishDir, double wishSpeed, double accel)
    {
        double currentSpeed = vel dot wishDir;

        double addSpeed = wishSpeed - currentSpeed;
        if (addSpeed <= 0) return;

        /*double friction, moveFactor;
        [friction, moveFactor] = GetFriction();
        accel *= friction > normalFriction ? moveFactor / ORIG_FRICTION_FACTOR : 1;   // Don't want stickiness*/

        /*double moveFactor = GetMoveFactor();
        accel *= moveFactor;*/

        //Console.Printf("%.2f", moveFactor);

        double accelSpeed = Clamp(accel * wishSpeed, 0, addSpeed);

        vel += accelSpeed * wishDir;
    }


    virtual void BobAccelerate(Vector3 wishDir, double wishSpeed, double accel)
    {
        double currentSpeed = player.vel dot wishDir.xy;

        double addSpeed = wishSpeed - currentSpeed;
        if (addSpeed <= 0) return;

        double accelSpeed = Clamp(accel * wishSpeed, 0, addSpeed);

        player.vel += accelSpeed * wishDir.xy;
    }


    // Returns whether player is walking, swimming, etc.
    virtual int GetMoveType()
    {
        if (waterLevel > WL_Feet)   return MT_Water;
        if (bNoGravity)             return MT_Fly;
        if (player.onGround)        return MT_Walk;
        else                        return MT_Air;
    }


    // Slow player down if ground is slippery/sticky
    virtual double GetMoveFactor()
    {
        double friction = GetFriction();

        if (friction > normalFriction) return 1 - ((friction - normalFriction) / (1 - normalFriction));
        else if (friction < normalFriction) return 1 - ((normalFriction - friction) / normalFriction);
        else return 1;
    }


    bool IsPressed(int bt)
    {
        return player.cmd.buttons & bt;
    }


    bool JustPressed(int bt)
    {
        return (player.cmd.buttons & bt) && !(player.oldButtons & bt);
    }
}