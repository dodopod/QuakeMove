// Code adapted from PlayerPawn & DoomPlayer in gzdoom.pk3

class QuakePlayer : DoomPlayer
{
    // Aliases for Player.Forward/SideMove
    Property ForwardMove : forwardMove1, forwardMove2;
    Property SideMove : sideMove1, sideMove2;

    Property UpMove : upMove;


    Default
    {
		Speed 320.0 / ticRate;  // No idea how close Doom & Quake units are, but it feels right

        QuakePlayer.UpMove 0.5;

        +NoFriction
    }


    const straferunningCVar = "G_Straferunning";
    const strafejumpingCVar = "G_Strafejumping";

    const maxForwardMove = 12800;
    const maxSideMove = 10240;
    const maxUpMove = 768;
    const stopFlying = -32768;

    const normalFriction = 0.90625;
    const ups = 1.0 / ticRate;

    const stopSpeed = 100.0 / ticRate;
    const duckScale = 0.25;
    const swimScale = 0.5;

    const groundAccelerate = 10.0 / ticRate;    // TODO: aircontrol, etc.
    const airAccelerate = 1.0 / ticRate;
    const waterAccelerate = 4.0 / ticRate;
    const flyAccelerate = 8.0 / ticRate;

    const groundFriction = 6.0 / ticRate;
    const waterFriction = 1.0 / ticRate;
    const flightFriction = 5.0 / ticRate;

    enum EWaterLevel
    {
        WL_NotInWater   = 0,
        WL_Feet         = 1,
        WL_Waist        = 2,
        WL_Eyes         = 3
    }

    enum EMoveType
    {
        MT_Walk,
        MT_Water,
        MT_Fly,
        MT_Air
    }


    double upMove;


    override void PlayerThink()
    {
        bool predicting = player.cheats & CF_Predicting;

        CheckFOV();
        if (player.inventoryTics) --player.inventoryTics;
        CheckCheats();

		if (player.playerState == PST_Dead)
		{   // Is there a reason CheckCrouch is before this in gzdoom.pk3?
			DeathThink();
			return;
		}
		if (player.morphTics && !predicting)
		{
			MorphPlayerThink();
		}

		player.onGround = (pos.z <= floorZ) || bOnMobj || bMBFBouncer || (player.cheats & CF_NoClip2);
        HandleMovement();

        if (!predicting)
        {
            // NOTE: CheckUndoMorph may change PlayerPawn, and invalidate self.player (I think)
            PlayerInfo player = self.player;

            CheckEnvironment();
			CheckUse();
			CheckUndoMorph();

			player.mo.TickPSprites();

			// Other Counters
			if (player.damagecount)	player.damagecount--;
			if (player.bonuscount) player.bonuscount--;

            // Strife-style poison
			if (player.hazardcount)
			{
				player.hazardcount--;
				if (!(level.time % player.hazardinterval) && player.hazardcount > 16 * ticRate)
					player.mo.DamageMobj (NULL, NULL, 5, player.hazardtype);
			}

			player.mo.CheckPoison();
			player.mo.CheckDegeneration();
			player.mo.CheckAirSupply();
        }
    }


    override void HandleMovement()
    {
        FixPlayerInput();
        CheckCrouch(CheckFrozen());

        CheckPitch();

		if (reactiontime)
		{   // Player is frozen
			reactiontime--;
		}
		else
		{
            CheckYaw();

            switch (GetMoveType())
            {
            case MT_Walk:
                WalkMove();
                break;
            case MT_Fly:
                FlyMove();
                break;
            case MT_Water:
                WaterMove();
                break;
            case MT_Air:
                AirMove();
                break;
            }
		}

        CalcHeight();   // Vertical bob
    }


    // Modifies player input in special circumstances
    virtual void FixPlayerInput()
    {
        UserCmd cmd = player.cmd;

        PullIn();

        switch (GetMoveType())
        {
        case MT_Fly:
        case MT_Water:
            if (IsPressed(BT_Jump))
            {
                cmd.upMove = maxUpMove;
            }

            if (IsPressed(BT_Crouch))
            {
                cmd.upMove = -maxUpMove;
            }

            break;
        }
    }


    // Chainsaw/Gauntlets attack auto forward motion
    virtual void PullIn()
    {
        UserCmd cmd = player.cmd;

		if (bJustAttacked)
		{
			cmd.yaw = 0;
			cmd.forwardmove = 0xc800/2;
			cmd.sidemove = 0;
			bJustAttacked = false;
		}
    }


    // Handle player turning
    virtual void CheckYaw()
    {
        UserCmd cmd = player.cmd;

        // [RH] Check for fast turn around
		if (player.cmd.buttons & BT_TURN180 && !(player.oldbuttons & BT_TURN180))
		{
			player.turnticks = TURN180_TICKS;
		}

		// [RH] 180-degree turn overrides all other yaws
		if (player.turnticks)
		{
			player.turnticks--;
			Angle += (180. / TURN180_TICKS);
		}
		else
		{
			Angle += cmd.yaw * (360./65536.);
		}
    }


    override void CheckJump()
    {
        if (JustPressed(BT_Jump))
        {
            // Copypasted from CheckJump
            if (player.crouchoffset != 0)
            {
                // Jumping while crouching will force an un-crouch but not jump
                player.crouching = 1;
            }
            else if (level.IsJumpingAllowed() && player.onGround)
            {
                double jumpvelz = JumpZ * 35 / TICRATE;
                double jumpfac = 0;

                // [BC] If the player has the high jump power, double his jump velocity.
                // (actually, pick the best factors from all active items.)
                for (let p = Inv; p != null; p = p.Inv)
                {
                    let pp = PowerHighJump(p);
                    if (pp)
                    {
                        double f = pp.Strength;
                        if (f > jumpfac) jumpfac = f;
                    }
                }
                if (jumpfac > 0) jumpvelz *= jumpfac;

                Vel.Z += jumpvelz;
                bOnMobj = false;
                player.onGround = false;
                if (!(player.cheats & CF_PREDICTING)) A_PlaySound("*jump", CHAN_BODY);
            }
        }
    }


    virtual void WalkMove()
    {
		UserCmd cmd = player.cmd;

        // Start flying
        if (cmd.upMove)
        {
            if (bFly || (player.cheats & CF_NOCLIP2))
            {
                bFly = true;
                bNoGravity = true;

                if ((Vel.Z <= -39) && !(player.cheats & CF_PREDICTING))
                {   // Stop falling scream
                    A_StopSound(CHAN_VOICE);
                }

                FlyMove();
                return;
            }
            else if (cmd.upMove > 0 && !(player.cheats & CF_PREDICTING))
			{
				let fly = FindInventory("ArtiFly");
				if (fly)
                {
                    UseInventory(fly);

                    FlyMove();
                    return;
                }
			}
        }

        CheckJump();
        if (!player.onGround)
        {
            if (waterLevel) WaterMove();
            else AirMove();

            return;
        }

        Friction();

        if (cmd.forwardMove || cmd.sideMove)
        {
			double fm = cmd.forwardmove;
			double sm = cmd.sidemove;
			[fm, sm] = TweakSpeeds(fm, sm);
            fm /= maxForwardMove;
            sm /= maxSideMove;

            bool canStraferun = CVar.FindCVar(straferunningCVar).GetBool();
            double scale = canStraferun ? speed : CmdScale();
            fm *= scale;
            sm *= scale;

            Vector3 forward = (AngleToVector(angle), 0);
            Vector3 right = (AngleToVector(angle - 90), 0);
            Vector3 wishVel = fm * forward + sm * right;

            Vector3 wishDir = wishVel.Unit();
            double wishSpeed = wishVel.Length();

            // Crouch walk is slower
            if (CanCrouch() && level.IsCrouchingAllowed() && IsPressed(BT_Crouch))
            {
                wishSpeed = Min(wishSpeed, speed * duckScale);
            }

            // So is wading
            if (waterlevel)
            {
                double waterScale = double(waterLevel) / 3;
                waterScale = 1 - (1 - swimScale) * waterScale;
                wishSpeed = Min(wishSpeed, speed * waterScale);
            }

            double accel = GetMoveFactor() * groundAccelerate;
            Accelerate(wishDir, wishSpeed, accel);
            BobAccelerate(wishDir, wishSpeed, accel);

            // Running animation
			if (!(player.cheats & CF_PREDICTING) && (fm != 0 || sm != 0)) PlayRunning();

            // Return to 1st person (from security camera?)
			if (player.cheats & CF_RevertPlease)
			{
				player.cheats &= ~CF_RevertPlease;
				player.camera = player.mo;
			}
        }
    }


    virtual void FlyMove()
    {
		UserCmd cmd = player.cmd;

        if (cmd.upMove == stopFlying)
        {
            bNoGravity = false;
            cmd.upMove = 0; // To avoid AirMove calling FlyMove again
            AirMove();
            return;
        }

        Friction();

        if (cmd.forwardMove || cmd.sideMove || cmd.upMove)
        {
			double fm = cmd.forwardmove;
			double sm = cmd.sidemove;
            double um = cmd.upMove;
            [fm, sm, um] = TweakSpeeds3(fm, sm, um);
            fm /= maxForwardMove;
            sm /= maxSideMove;
            um /= maxUpMove;

            bool canStraferun = CVar.FindCVar(straferunningCVar).GetBool();
            double scale = canStraferun ? speed : CmdScale();
            fm *= scale;
            sm *= scale;
            um *= scale;

            Vector3 forward = (Cos(pitch) * Cos(angle), Cos(pitch) * Sin(angle), -Sin(pitch));
            Vector3 right = (AngleToVector(angle - 90), 0);
            Vector3 wishVel = fm * forward + sm * right;
            wishVel.z += um;

            Vector3 wishDir = wishVel.Unit();
            double wishSpeed = wishVel.Length();

            double accel = GetMoveFactor() * flyAccelerate;
            Accelerate(wishDir, wishSpeed, accel);
            BobAccelerate(wishDir, wishSpeed, accel);

            // Running animation
			if (!(player.cheats & CF_PREDICTING) && (fm != 0 || sm != 0)) PlayRunning();

            // Return to 1st person (from security camera?)
			if (player.cheats & CF_RevertPlease)
			{
				player.cheats &= ~CF_RevertPlease;
				player.camera = player.mo;
			}
        }
    }


    virtual void WaterMove()
    {
		UserCmd cmd = player.cmd;

        Friction();

        if (cmd.forwardMove || cmd.sideMove || cmd.upMove)
        {
			double fm = cmd.forwardmove;
			double sm = cmd.sidemove;
            double um = cmd.upMove;
            [fm, sm, um] = TweakSpeeds3(fm, sm, um);
            fm /= maxForwardMove;
            sm /= maxSideMove;
            um /= maxUpMove;

            bool canStraferun = CVar.FindCVar(straferunningCVar).GetBool();
            double scale = canStraferun ? speed : CmdScale();
            fm *= scale;
            sm *= scale;
            um *= scale;

            Vector3 forward = (Cos(pitch) * Cos(angle), Cos(pitch) * Sin(angle), -Sin(pitch));
            Vector3 right = (AngleToVector(angle - 90), 0);
            Vector3 wishVel = fm * forward + sm * right;
            wishVel.z += um;

            if (waterLevel == WL_Feet && wishVel.z > 0) wishVel.z = 0;   // Swim on surface
            if (wishVel.Length() == 0) return;

            Vector3 wishDir = wishVel.Unit();
            double wishSpeed = wishVel.Length();

            wishSpeed = Min(wishSpeed, speed * swimScale);

            double accel = GetMoveFactor() * waterAccelerate;
            Accelerate(wishDir, wishSpeed, accel);
            BobAccelerate(wishDir, wishSpeed, accel);

            // Running animation
			if (!(player.cheats & CF_PREDICTING) && (fm != 0 || sm != 0)) PlayRunning();

            // Return to 1st person (from security camera?)
			if (player.cheats & CF_RevertPlease)
			{
				player.cheats &= ~CF_RevertPlease;
				player.camera = player.mo;
			}
        }
    }


    virtual void AirMove()
    {
		UserCmd cmd = player.cmd;

        // Start flying
        if (cmd.upMove)
        {
            if (bFly || (player.cheats & CF_NOCLIP2))
            {
                bFly = true;
                bNoGravity = true;

                if ((Vel.Z <= -39) && !(player.cheats & CF_PREDICTING))
                {   // Stop falling scream
                    A_StopSound(CHAN_VOICE);
                }

                FlyMove();
                return;
            }
            else if (cmd.upMove > 0 && !(player.cheats & CF_PREDICTING))
			{
				let fly = FindInventory("ArtiFly");
				if (fly)
                {
                    UseInventory(fly);

                    FlyMove();
                    return;
                }
			}
        }

        CheckJump();    // In case CheckJump is overridden to allow double jump, mantling, etc.
        Friction();

        if (cmd.forwardMove || cmd.sideMove)
        {
			double fm = cmd.forwardmove;
			double sm = cmd.sidemove;
			[fm, sm] = TweakSpeeds(fm, sm);
            fm /= maxForwardMove;
            sm /= maxSideMove;

            bool canStraferun = CVar.FindCVar(straferunningCVar).GetBool();
            double scale = canStraferun ? speed : CmdScale();
            fm *= scale;
            sm *= scale;

            Vector3 forward = (AngleToVector(angle), 0);
            Vector3 right = (AngleToVector(angle - 90), 0);
            Vector3 wishVel = fm * forward + sm * right;

            Vector3 wishDir = wishVel.Unit();
            double wishSpeed = wishVel.Length();

            double accel = GetMoveFactor() * airAccelerate;
            Accelerate(wishDir, wishSpeed, accel);
            BobAccelerate(wishDir, wishSpeed, accel);

            // Running animation
			if (!(player.cheats & CF_PREDICTING) && (fm != 0 || sm != 0)) PlayRunning();

            // Return to 1st person (from security camera?)
			if (player.cheats & CF_RevertPlease)
			{
				player.cheats &= ~CF_RevertPlease;
				player.camera = player.mo;
			}
        }
    }


    virtual double, double, double TweakSpeeds3(double forward, double side, double up)
    {
        [forward, side] = TweakSpeeds(forward, side);

        up *= upMove;

        return forward, side, up;
    }


    virtual double CmdScale()
    {
		UserCmd cmd = player.cmd;
        double fm = double(cmd.forwardMove) / maxForwardMove;
        double sm = double(cmd.sideMove) / maxSideMove;
        double um = double(cmd.upMove) / maxUpMove;

        double maxCmd = Max(Abs(fm), Abs(sm), Abs(um));
        double total = (fm, sm, um).Length();

        return total ? speed * maxCmd / total : 0;
    }


    virtual void Friction()
    {
        double spd = vel.Length();
        if (spd < ups)
        {
            vel.xy = (0, 0);
            player.vel = (0, 0);
            return; // Prevents div by 0
        }

        double drop = 0;

        if (waterLevel <= WL_Feet && player.onGround)
        {
            double control = spd < stopSpeed ? stopSpeed : spd;
            drop += control * groundFriction;
            drop *= GetMoveFactor();
        }

        if (waterLevel)
        {
            drop += spd * waterFriction * waterLevel;
        }

        if (bNoGravity)
        {
            drop += spd * flightFriction;
        }

        double newSpeed = Max(spd - drop, 0) / spd;
        vel *= newSpeed;
        player.vel *= newSpeed;
    }


    virtual void Accelerate(Vector3 wishDir, double wishSpeed, double accel)
    {
        if (CVar.FindCVar(strafejumpingCVar).GetBool())
        {
            double currentSpeed = vel dot wishDir;

            double addSpeed = wishSpeed - currentSpeed;
            if (addSpeed <= 0) return;

            double accelSpeed = Min(accel * wishSpeed, addSpeed);

            vel += accelSpeed * wishDir;
        }
        else
        {   // Disabled code in Quake 3
            Vector3 pushDir = wishSpeed * wishDir - vel;
            double pushLen = pushDir.Length();
            if (pushLen == 0) return;
            pushDir = pushDir.Unit();

            double canPush = Min(accel * wishSpeed, PushLen);

            vel += canPush * pushDir;
        }
    }


    virtual void BobAccelerate(Vector3 wishDir, double wishSpeed, double accel)
    {
        double currentSpeed = player.vel dot wishDir.xy;

        double addSpeed = wishSpeed - currentSpeed;
        if (addSpeed <= 0) return;

        double accelSpeed = Clamp(accel * wishSpeed, 0, addSpeed);

        player.vel += accelSpeed * wishDir.xy;
    }


    // Returns whether player is walking, swimming, etc.
    virtual int GetMoveType()
    {
        if (bNoGravity)             return MT_Fly;
        if (waterLevel > WL_Feet)   return MT_Water;    // In Quake, you can only swim when waist deep
        if (waterLevel == WL_Feet                       // In Doom, you can practically walk on water
            && !player.onGround)    return MT_Water;    // This is a compromise, so you can jump in shallow water
        if (player.onGround)        return MT_Walk;
        else                        return MT_Air;
    }


    // Slow player down if ground is slippery/sticky
    virtual double GetMoveFactor()
    {
        double friction = GetFriction();

        if (friction > normalFriction) return 1 - ((friction - normalFriction) / (1 - normalFriction));
        else if (friction < normalFriction) return 1 - ((normalFriction - friction) / normalFriction);
        else return 1;
    }


    bool IsPressed(int bt)
    {
        return player.cmd.buttons & bt;
    }


    bool JustPressed(int bt)
    {
        return (player.cmd.buttons & bt) && !(player.oldButtons & bt);
    }
}
